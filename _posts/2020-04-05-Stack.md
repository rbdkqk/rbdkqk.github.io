---
title:  "재귀와 반복문 비교하기 - 스택(Stack) 메모리 구조"
excerpt: "\"메모리 측면에서 재귀보다 반복문이 유리하다?\""

categories:
  - studynote
tags:
  - Javascript
  - recursion
  - stack memory
last_modified_at: 2020-04-05
---


<br>


공부중에 알게 된 것들이나 느낀 것들 등등을 남기기 위해 이 블로그를 시작하였습니다.

첫 포스팅의 주제로 '재귀와 반복문의 차이를 비교'하는 내용을 선택했습니다.

문제풀이의 경험과 친구의 조언을 토대로 공부한 내용을 정리해 두려 합니다.

<br>
<br>

# '메모리 측면에서 재귀보다 반복문이 유리하다?'

자바스크립트 공부를 하던 중, 재귀 부분의 문제를 풀고 난 뒤에, 아래와 같은 문제를 만났습니다.

>Summation to n: Let's implement the function sum that takes a single parameter n, and computes the sum of all integers up to n starting from 0, e.g.:
>
>(n까지의 총 합: n을 매개변수로 받아 0 부터 n 까지 모든 수의 총 합을 반환하는 함수를 작성하세요.)

토이 문제중에서도 별 1개짜리 간단한 문제였는데, 저는 재귀를 풀고 난 직후여서 별다른 생각 없이 재귀를 활용하여 아래와 같이 문제를 해결하였습니다.

```js
function sum(n) {
  if (n <= 0) {
    return 0;
  }
  else {
    return n + sum(n-1);
  }
}
```

다 풀고 난 뒤 모델 솔루션을 참고하니, 0부터 n까지 합을 누적시키는 반복문으로 문제를 해결하는 방법을 제시해 주셨더라구요.

뭔가 다른 방법으로 해결한 것이 아닐까 하는 기쁜 마음에, 이렇게 해결한 결과물을 친구에게 보여주었습니다.

위 코드를 본 친구는 아래와 같이 조언해 주었습니다.

>이 경우에는 반복문이 더 효율적임.  
>재귀를 사용하게 되면 스택이라는 구조의 메모리 할당이 반드시 생기는데, 메모리 면에서 더 비효율적임.  

그래서, 같은 결과를 얻기 위한 과정에서, **'재귀와 반복문을 사용할 경우 메모리에서 어떤 차이가 생기는지'**를 알아보려 합니다.

<br>
<br>

# 메모리 구조

&nbsp;&nbsp;&nbsp;&nbsp;메모리 구조가 무엇인지에 관해 먼저 공부하였습니다.

1. 메모리(memory)란 무엇인가?  

    (1) RAM(Ramdom Access Memory)이라고 불리는 메모리는, **'이후에 불러오기 위해서 일정한 정보를 기억하기 위한 공간'** 입니다.  
    - 컴퓨터의 주기억장치에 해당하며, 사람의 업무처리에 비교하자면 업무를 위해 이런저런 자료를 꺼내서 깔아놓는 '책상'이라고 할 수 있습니다.  
    - 책상이 넓고 쾌적하다면 업무효율이 도움이 될 것이고, 지금 당장 쓰지도 않을 자료를 너무 많이 꺼내둬서 실제 필요한 자료를 찾기 어렵다면 비효율적인 업무처리로 이어질 것입니다.<br><br>


    (2) 메모리에서의 자료 처리 과정은 다음과 같습니다.  
    - 할당(allocate) : '필요할 때 할당한다'  
        - 변수나 상수 등의 자료가 주어지면, 이후에 프로그램이 이를 사용할 수 있도록 메모리를 할당해야 합니다.  
    - 사용(use) : '사용한다 (읽기/쓰기)'  
       - 위에서 할당된 메모리를 실제 프로그램에서 사용하게 됩니다. 이 과정에서 단순히 메모리를 불러올 수도 있고, 새로운 값을 할당할 수도 있습니다.  
    - 해제(release) : '필요없어지면 해제한다'  
        - 더이상 필요하지 않게 된 메모리는 해제되어 다시 사용할 수 있는 상태가 됩니다.<br><br>


    (3) 메모리의 특징
    - RAM은 정보를 자유롭게 쓰고 읽고 다시 쓸 수 있습니다.  
        - CPU(중앙처리장치)에서 연산한 결과를 메모리에 저장합니다.
        - 이후 이를 자유롭게 읽어오거나, 다시 이 위치에 새로운 연산결과를 덮어쓸 수 있습니다.
    - RAM은 휘발성을 갖습니다.  
        - 따라서, RAM에 저장되는 자료는 전기가 차단되면 모두 사라집니다.  
        - 전기가 차단되어도 사라지지 않아야 하는 자료들은 보조기억장치(HDD, SSD 등)에 저장합니다.       
    - C 등의 언어에서는 메모리의 할당과 해제를 명시적으로 작성하여 처리해 주어야 합니다.  
        - 그러나, Javascript에서는 객체나 숫자 등의 자료가 생겨날 때(선언될 때) 메모리가 '자동으로' 할당되며, 이후 더이상 사용되지 않게 되면 '자동으로' 해제되어 메모리가 반환됩니다. 이런 과정을 'garbage collection' 이라고 합니다.<br><br>

2. 메모리 구조는 무엇인가?  
    &nbsp;&nbsp;&nbsp;&nbsp;프로그램이 실행되면 운영체제가 자료를 메모리에 할당합니다.  
    &nbsp;&nbsp;&nbsp;&nbsp;이렇게 할당해 주는 공간은 다음 4가지가 존재합니다.  

    (1) 코드 영역  
    - 작성한 코드가 저장되는 영역입니다.  
    - 함수, 제어문, 상수 등이 포함되며, Javascript 등의 개발 언어로 작성된 코드는 컴퓨터가 이해할 수 있는 기계어로 변환되어 저장됩니다.  <br><br>

    (2) 데이터 영역  
    - 전역변수와 정적변수(static)변수가 저장되는 영역입니다. 
    <!--(정적 변수가 무엇인지에 관하여 이후에 공부한 뒤 링크를 걸자.)-->  
    - 프로그램이 구동되는 동안 항상 접근 가능한 변수가 저장되는 영역이므로, 프로그램이 시작되면 할당되며 프로그램이 종료되면 소멸합니다.  <br><br>

    (3) 힙 영역  
    - 위에서 살펴본, 관리 가능한 데이터를 제외하고, 그 외의 다른 데이터들을 관리하기 위한 빈 공간입니다.  
    - 동적 할당을 통해 생성된 동적변수를 관리하기 위한 영역입니다.  
    - 이 공간은 사용자가 직접 관리할 수 있고, 직접 관리해야 하는 영역입니다.  
    - 데이터 영역과 스택 영역은 미리 공간을 예측하고 할당할 수 있습니다. 그러나, 동적변수는 어느 시점에 어느 정도의 공간으로 할당될지를 정확하게 예측할 수 없기 때문에, 프로그램 실행 중(Runtime)에 그 크기가 결정됩니다.  <br><br>

    (4) 스택 영역  
    - 함수, 메서드 등 안에서 임시로 사용하는 영역입니다.  
    - 함수 호출시에 생성되는 지역변수와 매개변수가 저장되며, 함수의 호출이 완료되면 사라집니다.  

    - '스택(stack)'은 단어 그대로 무엇인가가 '쌓인다'는 뜻입니다.  
    - 가령, A함수가 B함수를 호출하고, B함수가 C함수를 호출하는 방식의 연쇄적인 구조에서, 메모리에 값이 '쌓이는' 순서는 A-B-C 이지만, 실제 결과값이 반환되는 순서는 반대로 C-B-A 순서입니다.  
    - 값이 아래에서부터 '쌓여' 있으므로, 가장 마지막에 들어간 것이 가장 먼저 나오는 결과를 볼 수 있습니다. (LIFO, Last Input First Output, 후입선출)  

    - 함수 하나가 실행되면, 그 함수에서 사용되는 지역변수의 메모리가 스택에 쌓이고, 그 함수가 모두 종료되면 처리가 끝났으므로 비로소 메모리를 해제합니다.  
        
<br>
<br>

# 재귀와 스택  

 1. 재귀란 무엇인가  
 &nbsp;  
  &nbsp; 재귀(recursion)란, 자신을 정의할 때 자기 자신을 다시 참조하는 것을 말합니다.  
  &nbsp;  
  &nbsp; 따라서 재귀함수는 함수 내부에서 자기 자신을 다시 호출하는 형태를 갖게 됩니다.  
<br>

 2. 제가 작성한 코드를 다시 살펴보겠습니다.  
```js
function sum(n) {
  if (n <= 0) {
    return 0;
  }
  else {
    return n + sum(n-1);
  }
}
```  
&nbsp;  
     n === 1 의 경우, 1과 sum(1-1)의 결과값을 합산한 값이 최종 반환됩니다.  
     &nbsp;  
     n === 2 의 경우, 2와 sum(2-1)의 결과값을 합산한 값이 최종 반환됩니다. 다만 이 경우에 sum(2-1)의 결과값을 반환하기 위해서는 sum(1-1)의 결과값이 먼저 반환되어야 합니다.  
<br>

 3. 재귀에서는 메모리에 스택 영역에 실행 컨텍스트가 쌓이게 됩니다.  
 &nbsp;  
    &nbsp; 위에서 살펴본 메모리 구조 중, '스택 영역'과의 연관성을 고려해야 합니다.  
    &nbsp;  
    &nbsp; 함수가 실행될 때, 그 실행중인 함수의 세부 정보들(제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등등)은 해당 함수의 **실행 컨텍스트(execution context)**에 저장됩니다. (함수 호출 1회당 하나의 실행 컨텍스트가 생성되어 저장됩니다.)  
    &nbsp;  
    &nbsp; 스택 영역에서는 자료의 입력과 출력이 한쪽 끝에서만 일어나므로, 최초 불러온 함수의 결과값을 얻기 위해서는 재귀로 다시 불러온 최종 함수의 결과값에서부터 거꾸로 하나씩 되돌아오는 과정을 거쳐야만 합니다.  
    &nbsp;  
    &nbsp; 그래서 위 예시와 같이, sum 함수 그 자체를 스스로 여러번 반복하여 실행하고, 가장 나중에 실행된 값부터 불러와서, 최종의 결과값을 반환하는 결과를 보게 됩니다.  
    &nbsp;  
    &nbsp; 스택 영역은 위에서 살펴본 바와 같이, **'함수 호출시에 생성되는 지역변수와 매개변수가 저장되며, 함수의 호출이 완료되면 사라집니다.'** 그러므로, 재귀함수가 자기 스스로를 참조하여 스스로를 다시 불러올때마다, 메모리의 스택 영역에 새로운 실행 컨텍스트가 계속하여 쌓이는 결과를 초래합니다.  
    &nbsp;  
    &nbsp; 이렇게 되면 매번 재귀함수를 호출할때마다 스택이 쌓이면서 메모리의 공간이 갈수록 줄어들고, 결국 아래의 '스택 오버플로우' 문제가 발생합니다.  
<br>

 4. 스택 오버플로우 (stack overflow)  
 &nbsp;  
    &nbsp; 가령 위 코드에서 if (n <= 0) {return 0;} 부분이 없다면, n-1은 음수 방향으로 무한히 뻗어갈 수 있게 됩니다.  
    &nbsp;  
    &nbsp; 그러므로 n에 어떤 값을 주어도 위 함수는 멈추지 않고 자기 스스로를 계속 호출하는 결과가 나오며, 한 번의 호출에서 함수가 종료되지 않고 이른바 '무한루프'에 빠지게 됩니다.  
    &nbsp;  
    &nbsp; 메모리 공간의 스택 영역은 한정되어 있으므로, 무한루프를 통해 계속 쌓이는 스택은 언젠가는 메모리의 스택 영역에서 감당하지 못하고 프로그램이 멈추게 됩니다.  
    &nbsp;  
    &nbsp; 이런 오류를 막기 위해, 재귀함수를 작성할 때에는 재귀 호출을 종료하는 부분이 꼭 들어가야 합니다. 위 코드의 if (n <= 0) {return 0;} 부분이 이에 해당하며, 이러한 조건을 'Base case' 또는 'Termination case' 라고 합니다.  
<br>

 5. 스택 구조의 메모리 비효율성  
 &nbsp;  
   &nbsp;이와 같이 'Base case' 조건을 주게 되면 재귀함수에서 스택 오버플로우가 발생할 가능성은 적어집니다.  
   &nbsp;  
   &nbsp;그러나, 스택 오버플로우가 발생하지 않더라도, 재귀함수의 호출만으로도 매번의 호출마다 각각의 실행 컨텍스트 자체는 결국 메모리의 스택 영역에 쌓이게 됩니다.  
   &nbsp;  
   &nbsp;가령 위 코드에서 1,000,000이라는 숫자를 대입한다면 sum함수를 1,000,000번 불러와야 하고 각각의 실행 컨텍스트 역시 그만큼 쌓이게 됩니다. (위 코드로 크롬 개발자도구 콘솔에서 실험해 보니 11439까지는 함수가 실행되었고 11440부터는 Maximum call stack size exceeded 에러가 발생하였습니다.)  
   &nbsp;  
   &nbsp;아래에서부터 차례로 값을 쌓아가고 불러올때는 위에서부터 불러오는 스택 영역의 구조상, **위에서부터 차례대로 값을 반환하여 최종 결과값을 반환하기 전까지는 스택 영역의 메모리는 계속 차지하고 있는 상태로 유지됩니다**.  
   &nbsp;  
   &nbsp;그러므로, 함수가 처리되는 중에 이와 같이 실행 컨텍스트가 누적되어 메모리가 소비되는 상태가 유지되고 있는 것이, 프로그램의 구동 전체에서 악영향을 미칠 수 있다는 점을 고려해야 합니다.

<br>
<br>

# 재귀와 반복문의 비교
 - 위에서 살펴본 바와 같이, 함수를 재귀 형태로 구성하여 실행하게 되면 매번의 호출마다 새로운 실행 컨텍스트가 스택 영역에 누적되어 메모리를 계속 차지하게 됩니다.
 - 그러나, 같은 결과를 얻기 위해 코드를 반복문으로 작성하는 경우, 함수는 1회만 호출되므로 실행 컨텍스트 역시 1회 생성되고 사용하는 메모리 공간 역시 고정됩니다.
 - 메모리의 스택 영역에서 두 방법은 이러한 차이를 보이므로, 반복문을 활용하는 경우 함수 호출의 비용으로써의 메모리 공간을 절약할 수 있습니다.
 - 그러나, 재귀를 반복문으로 수정하여 작성하여도 효율적이지 않은 경우가 있습니다. 자료의 깊이가 깊어서 매 깊이마다 별도의 반복문을 작성하면 코드가 길어지게 되는 경우 등입니다.
 - 재귀를 사용하면 코드의 길이가 짧아지고 가독성에서 유리하므로 보다 쉽게 이해할 수 있으며 유지보수에서도 장점을 찾을 수 있습니다. 오히려 이런 방법이 최적화에 도움이 되는 경우도 있을 것입니다.

<br>
<br>

# 작성후기 및 참조
 - 첫 포스트를 작성하면서, 아래와 같은 좋은 글을 많이 참조하였습니다.
     - [[JS/Recursion] 자바스크립트, 재귀함수에 대하여 (Recursion)](https://im-developer.tistory.com/102#recentComments)
     - [자료구조(스택, stack)](https://www.zerocho.com/category/Algorithm/post/5800b79e1dfb250015c38db6)
     - [메모리 구조(Memory Structure)](https://goodgid.github.io/Memory-Structure/)
     - [[컴퓨터 기초] 메모리구조(Memory Structure)](https://jinshine.github.io/2018/05/17/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B8%B0%EC%B4%88/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B5%AC%EC%A1%B0/)
     - [재귀와 스택](https://ko.javascript.info/recursion)
     - [메모리의 구조](http://tcpschool.com/c/c_memory_structure)
     - [힙 메모리 영역과 스택 메모리 영역 (메모리 영역)](https://ooz.co.kr/244)
     - [[Reversing] 스택(Stack) 메모리 구조와 스택 프레임(Stack Frame)](https://wisetrue.tistory.com/77)
     - [자바스크립트의 메모리관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)
     - [Javascript 메모리 에 대하여!](https://steemit.com/kr/@cicada0014/2wvmzm-javascript)
     - [자바스크립트는 어떻게 작동하는가: 메모리 관리 + 4가지 흔한 메모리 누수 대처법](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d)
     - Learning JaverScript (이선 브라운 지음, 한선용 옮김, 한빛미디어)
 - 참조라고 적었지만 사실 많은 내용을 거의 그대로 가져다 옮긴 느낌입니다. 작성자분들께 허락을 구하지 않고 내용을 참조하는 점 양해를 부탁드리며, 이 부분을 지적해 주신다면 언제든 삭제/수정하도록 하겠습니다.
 - 재귀와 반복문을 비교해 보려는 의도였는데, 실제로는 그 부분보다는 메모리에 관한 기초지식을 더 많이 작성한 것 같습니다. 또한, 실제의 코드 예시를 가지고 재귀와 반복문을 비교하여 작성하였다면 더 좋지 않았을까 합니다. 추후 더 공부하여 이 부분을 보완하도록 하겠습니다.
 - 코딩 초보가 작성한 첫번째 블로그 글이라 부족한 점이 매우 많을 것으로 생각합니다. 작성한 내용에 오류가 있거나 수정/보완할 내용이 있다면 지적해 주시면 정말 감사하겠습니다.
 - 앞으로도 공부하면서 만나는 문제나 배운 내용을 이렇게 작성해 나가려고 합니다. 읽어주셔서 감사합니다.
